# -*- coding: utf-8 -*-
"""transcript to vtt.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ywvqW2I5nxIOPcWL6Kh2Gso1fBdzhFR0

#Dependencies
"""

# !pip install beautifulsoup4

"""#Python is life

Use match ratio between strings, generally >=90% should be good. 

	Take character name preceding ‘:’ and put that into the vtt file as a voice tag before the appropriate dialog
		Store the value of string before ‘:’ and until new line is reached, for each match in the .vtt file, put that character name as the voice tag for the dialogue and go to next dialogue
	Then go to the end of the line and skip the time intervals and repeat steps for the next string

## Download webpage
"""

import requests
page = requests.get("http://www.livesinabox.com/friends/season2/212toasb.htm")
page.content

"""## Traverse webpage to extract dialogues with beautifulsoup
### Extract character names from the transcript, using ':'
"""

import bs4
from bs4 import BeautifulSoup
soup = BeautifulSoup(page.content, 'html.parser')

html = list(soup.children)
# print(type(html[4]))

# [type(item) for item in list(soup.children)]

# html[4] has the dialogues that I need
# print(html[4].text)

# find all unique words succeeded by ':'
# take from 'unique_name: sentence' in transcript and compare if 80% or more from the subtitle file matches to the transcript
# random ass \n in the dialogues so I'll have to capture until '.'
import re

match = re.finditer(r'(\w+.?\w*:(.+\n)+?  <b)', html[4].prettify())

  # [match[0] for match in re.finditer(r'(\w+.?\w*:(.+\n)+?  <b)', html[4].prettify())]
# match = re.search(r'\w+.?\w*:(.+\n)+?  <?', html[4].prettify())
# match.group(0)

# !pip install pysubs2

# Load subtitle file using pysubs2
# Do comparison of first dialogue in the match array with that of the subtitle file
  # Then retrieve char name using group(n) and store that into the subtitle file as voice tag using pysubs2 .name field

import pysubs2

subs = pysubs2.load('friends.s02e12.720p.bluray.x264-psychd.srt')

# print(subs[0].text)

for sub in subs:
  if sub.name is not '':
    print(sub.name)

# for each string in match array, look for a match for the subs[0].text string
  # for that I need all the strings in one array
  # iterator empties once all objects have been iterated over
  # save group(n) where n is the character name match, into the subs[x].name field, I suppose it's group(2) for character name
# match = re.finditer(r'((\w+.?\w*):(.+\n)+?  <b)', html[4].prettify())
for i, dialogue in enumerate(match):
  # print(dialogue.group(0))
  # exit()
  # print("---------")
  # if (i == 1):
    # break
  if subs[0].text in dialogue.group(0):
    # print(dialogue.group(2))
    print("1", dialogue.group(1))
    print("2", dialogue.group(2))
    subs[0].name = dialogue.group(2)

exit()

#matches strings with percent similarity, obvious problems with periods and exclamation marks etc

from difflib import SequenceMatcher

def similar(a, b):
    return SequenceMatcher(None, a, b).ratio()

# now repeat the above for each sub in the subtitle file
# hard to get exact matches, will have to either do string manipulation (strip all special characters, leaving only letters, probably the best way) or find a method that can return a percentage match( find how many characters are there and how many matched in the subs[n].text string, if it's fairly high then our match is found)


for sub in subs:
#   print(sub.text)
  match = re.finditer(r'((\w+.?\w*):(.+\n)+?  <b)', html[4].prettify())
  score = 0
  for dialogue in match:
    sub_strip = re.sub(r'\W+', ' ', sub.text).lower().strip(' ')
    dia_strip = re.sub(r'\W+', ' ', dialogue.group(0)).lower().strip(' ')
    sim_score = similar(sub_strip, dia_strip)
    
    if sim_score > score:
      score = sim_score
      print(sub_strip, dia_strip, similar(dia_strip, sub_strip), dialogue.group(2))
      #store name into sub
      # add if-else clause to only update if the new score is higher 
      sub.name = dialogue.group(2)

subs.save("my_subtitles_edited(no_lower_limit).ass")

for sub in subs:
   print(sub.name, sub.text)

subs_correct = pysubs2.load('friends_correctly_labeled.ass')

for index, sub in enumerate(subs2):
  if sub.name == subs[index].name:
    print('found match') #why no matches???

print(len(subs), len(subs2))

print(subs[0].name, subs_correct[0].name)

